#!/bin/bash

# tmux-session-manager: Comprehensive tmux session management with fuzzy finding
#
# Features:
# - Switch to active sessions (sorted by most recent, current session marked with →)
# - Kill sessions with Ctrl-x
# - Rename sessions with Ctrl-r
# - Start tmuxinator configs in background with Ctrl-s
# - Create new session with Ctrl-n
# - Toggle preview pane with Ctrl-p
# - Built-in help with ? key
# - Popup interface within tmux, regular fzf outside tmux
# - Color-coded indicators: green dots for active, grey dots for tmuxinator configs
# - Preview pane showing session details (windows, panes, working directory)

set -e

# Configuration
readonly CONFIG_DIR="$HOME/.config/tmux-session-manager"
readonly CONFIG_FILE="$CONFIG_DIR/config"

# Colors for output
readonly RED=$'\033[0;31m'
readonly GREEN=$'\033[1;32m'
readonly YELLOW=$'\033[1;33m'
readonly BLUE=$'\033[0;34m'
readonly DARK_GREY=$'\033[0;90m'
readonly NC=$'\033[0m' # No Color

# Load/save preview preference
load_preview_preference() {
  if [[ -f "$CONFIG_FILE" ]]; then
    source "$CONFIG_FILE" 2>/dev/null || true
  fi
  # Default to enabled if not set
  echo "${PREVIEW_ENABLED:-true}"
}

save_preview_preference() {
  local enabled="$1"
  mkdir -p "$CONFIG_DIR"
  echo "PREVIEW_ENABLED=$enabled" > "$CONFIG_FILE"
}

# Generate preview content for a session
generate_preview() {
  local session_name="$1"
  local selection="$2"

  # Check if it's a tmuxinator config
  if echo "$selection" | grep -q "(tmuxinator)"; then
    echo "${BLUE}Tmuxinator Configuration: $session_name${NC}"
    echo ""
    if [[ -f "$HOME/.dotfiles/tmuxinator/$session_name.yml" ]]; then
      echo "${YELLOW}Configuration file:${NC}"
      echo "$HOME/.dotfiles/tmuxinator/$session_name.yml"
      echo ""
      echo "${YELLOW}Config preview:${NC}"
      head -20 "$HOME/.dotfiles/tmuxinator/$session_name.yml" 2>/dev/null | sed 's/^/  /' || echo "  Could not read config file"
    else
      echo "Configuration file not found"
    fi
    return
  fi

  # Check if it's a git worktree
  if echo "$selection" | grep -q "(worktree)"; then
    local worktree_path
    worktree_path=$(get_worktree_path "$session_name")
    echo "${BLUE}Git Worktree: $session_name${NC}"
    echo ""
    if [[ -n "$worktree_path" && -d "$worktree_path" ]]; then
      echo "${YELLOW}Worktree path:${NC}"
      echo "$worktree_path"
      echo ""
      if cd "$worktree_path" 2>/dev/null; then
        echo "${YELLOW}Branch info:${NC}"
        git branch --show-current 2>/dev/null || echo "  Could not determine branch"
        echo ""
        echo "${YELLOW}Recent commits:${NC}"
        git log --oneline -5 2>/dev/null | sed 's/^/  /' || echo "  Could not read git log"
        echo ""
        echo "${YELLOW}Working directory status:${NC}"
        git status --porcelain 2>/dev/null | head -10 | sed 's/^/  /' || echo "  Clean working directory"
      else
        echo "Could not access worktree directory"
      fi
    else
      echo "Worktree path not found"
    fi
    return
  fi

  # Check if session is active
  if ! tmux has-session -t "$session_name" 2>/dev/null; then
    echo "${RED}Session '$session_name' is not active${NC}"
    echo ""
    echo "This session will be created when selected."
    return
  fi

  # Show live session content using tmux capture-pane
  # Get the active window and pane
  local active_window active_pane
  active_window=$(tmux list-windows -t "$session_name" -f '#{window_active}' -F "#{window_index}" 2>/dev/null | head -1)

  if [[ -n "$active_window" ]]; then
    active_pane=$(tmux list-panes -t "$session_name:$active_window" -f '#{pane_active}' -F "#{pane_index}" 2>/dev/null | head -1)

    if [[ -n "$active_pane" ]]; then
      # Show session header info
      echo "${GREEN}● $session_name${NC} (${YELLOW}$(tmux list-windows -t "$session_name" | wc -l | tr -d ' ') windows${NC})"
      echo "${DARK_GREY}────────────────────────────────────────${NC}"

      # Capture live pane content
      tmux capture-pane -ep -t "$session_name:$active_window.$active_pane" 2>/dev/null || {
        echo "${RED}Could not capture session content${NC}"
        echo "Session may be busy or inaccessible"
      }
    else
      echo "${RED}No active pane found in session${NC}"
    fi
  else
    echo "${RED}No active window found in session${NC}"
  fi
}

# Check dependencies
check_dependencies() {
  local deps=("tmux" "fzf")
  local missing=()

  for dep in "${deps[@]}"; do
    if ! command -v "$dep" &> /dev/null; then
      missing+=("$dep")
    fi
  done

  if [[ ${#missing[@]} -gt 0 ]]; then
    echo -e "${RED}Missing dependencies: ${missing[*]}${NC}" >&2
    exit 1
  fi
}

# Get active tmux sessions sorted by activity (most recent first)
get_active_sessions() {
  tmux list-sessions -F "#{session_last_attached}:#{session_name}" 2>/dev/null | \
    grep -v ":.*scratch.*$" | \
    sort -rn | cut -d: -f2 || true
}

# Get scratch sessions
get_scratch_sessions() {
  tmux list-sessions -F "#{session_last_attached}:#{session_name}" 2>/dev/null | \
    grep ":.*scratch.*$" | \
    sort -rn | cut -d: -f2 || true
}

# Get tmuxinator configurations
get_tmuxinator_configs() {
  if [[ -d "$HOME/.dotfiles/tmuxinator" ]]; then
    find "$HOME/.dotfiles/tmuxinator" -name "*.yml" -exec basename {} .yml \; | grep -v config
  fi
}

# Get git worktrees from current repository
get_git_worktrees() {
  local worktrees=""

  # Try current directory first
  if git rev-parse --git-dir &>/dev/null; then
    worktrees=$(git worktree list --porcelain 2>/dev/null | \
      awk '/^worktree/ {path = $2} /^branch/ {gsub(/^refs\/heads\//, "", $2); print path ":" $2}' | \
      while IFS=: read -r path branch; do
        # Skip the main worktree (current repo)
        if [[ "$path" != "$(git rev-parse --show-toplevel)" ]]; then
          # Use the basename of the path as session name
          basename "$path"
        fi
      done)
  fi

  # Also check from active session directories for additional worktrees
  if [[ -z "$worktrees" ]]; then
    local active_sessions
    active_sessions=$(get_active_sessions)
    while IFS= read -r session; do
      if [[ -n "$session" ]]; then
        local session_dir
        session_dir=$(get_session_working_directory "$session")
        if [[ -n "$session_dir" && -d "$session_dir" ]]; then
          # Try to get worktrees from this session's directory
          local session_worktrees
          session_worktrees=$(cd "$session_dir" 2>/dev/null && git worktree list --porcelain 2>/dev/null | \
            awk '/^worktree/ {path = $2} /^branch/ {gsub(/^refs\/heads\//, "", $2); print path ":" $2}' | \
            while IFS=: read -r path branch; do
              # Skip the main worktree
              if [[ "$path" != "$session_dir" ]]; then
                basename "$path"
              fi
            done)
          if [[ -n "$session_worktrees" ]]; then
            worktrees="$session_worktrees"
            break
          fi
        fi
      fi
    done <<< "$active_sessions"
  fi

  echo "$worktrees"
}

# Get worktree path by session name
get_worktree_path() {
  local session_name="$1"
  local worktree_path=""

  # Try current directory first
  if git rev-parse --git-dir &>/dev/null; then
    worktree_path=$(git worktree list --porcelain 2>/dev/null | \
      awk '/^worktree/ {path = $2} /^branch/ {gsub(/^refs\/heads\//, "", $2); print path ":" $2}' | \
      while IFS=: read -r path branch; do
        if [[ "$(basename "$path")" == "$session_name" ]]; then
          echo "$path"
          break
        fi
      done)
  fi

  # If not found, check from active session directories
  if [[ -z "$worktree_path" ]]; then
    local active_sessions
    active_sessions=$(get_active_sessions)
    while IFS= read -r session; do
      if [[ -n "$session" ]]; then
        local session_dir
        session_dir=$(get_session_working_directory "$session")
        if [[ -n "$session_dir" && -d "$session_dir" ]]; then
          # Try to find worktree from this session's git repository
          worktree_path=$(cd "$session_dir" 2>/dev/null && git worktree list --porcelain 2>/dev/null | \
            awk '/^worktree/ {path = $2} /^branch/ {gsub(/^refs\/heads\//, "", $2); print path ":" $2}' | \
            while IFS=: read -r path branch; do
              if [[ "$(basename "$path")" == "$session_name" ]]; then
                echo "$path"
                break
              fi
            done)
          if [[ -n "$worktree_path" ]]; then
            break
          fi
        fi
      fi
    done <<< "$active_sessions"
  fi

  echo "$worktree_path"
}

# Get session working directory (from active tmux session)
get_session_working_directory() {
  local session_name="$1"
  if tmux has-session -t "$session_name" 2>/dev/null; then
    # Get the working directory from the first window's first pane
    tmux display-message -t "$session_name" -p "#{pane_current_path}" 2>/dev/null
  fi
}

# Check if a worktree path matches any active session's working directory
is_worktree_path_active() {
  local worktree_path="$1"
  local active_sessions="$2"

  while IFS= read -r session; do
    if [[ -n "$session" ]]; then
      local session_dir
      session_dir=$(get_session_working_directory "$session")
      if [[ -n "$session_dir" && "$session_dir" == "$worktree_path" ]]; then
        return 0  # Found matching session
      fi
    fi
  done <<< "$active_sessions"
  return 1  # No matching session found
}

# Get tmuxinator config root path
get_tmuxinator_root() {
  local config_name="$1"
  local config_file="$HOME/.dotfiles/tmuxinator/$config_name.yml"

  if [[ -f "$config_file" ]]; then
    # Extract root path from tmuxinator config and expand tilde
    local root_path
    root_path=$(grep "^root:" "$config_file" 2>/dev/null | sed 's/^root: *//' | tr -d '"' | head -1)
    # Expand tilde to home directory
    root_path="${root_path/#\~/$HOME}"
    echo "$root_path"
  fi
}

# Check if a tmuxinator config exists for this worktree
get_tmuxinator_for_worktree() {
  local worktree_path="$1"
  local tmuxinator_configs="$2"

  # Convert to array to avoid potential issues with while loops
  local -a config_array
  IFS=$'\n' read -r -d '' -a config_array <<< "$tmuxinator_configs" || true

  for config in "${config_array[@]}"; do
    if [[ -n "$config" ]]; then
      local config_root
      config_root=$(get_tmuxinator_root "$config")
      if [[ -n "$config_root" && "$config_root" == "$worktree_path" ]]; then
        echo "$config"
        return 0
      fi
    fi
  done
  return 1
}

# Check if session is running in a worktree directory
is_session_in_worktree() {
  local session_name="$1"
  local session_dir
  session_dir=$(get_session_working_directory "$session_name")

  # Only check if we have a session directory
  if [[ -n "$session_dir" && -d "$session_dir" ]]; then
    # Check if this directory is a git worktree by looking for .git file (not directory)
    if [[ -f "$session_dir/.git" ]]; then
      # Additional verification: check if it's actually a worktree reference
      if grep -q "gitdir:" "$session_dir/.git" 2>/dev/null; then
        return 0
      fi
    fi
  fi
  return 1
}

# Build selection list with status indicators
build_session_list() {
  local active_sessions
  local scratch_sessions
  local tmuxinator_configs
  local git_worktrees
  local session_list=()
  local current_session=""

  # Get current session if inside tmux
  if [[ -n "${TMUX:-}" ]]; then
    current_session=$(tmux display-message -p "#{session_name}")
  fi

  # Get data
  active_sessions=$(get_active_sessions)
  scratch_sessions=$(get_scratch_sessions)
  tmuxinator_configs=$(get_tmuxinator_configs)
  git_worktrees=$(get_git_worktrees)

  # Add active sessions with indicator, excluding current session
  while IFS= read -r session; do
    if [[ -n "$session" && "$session" != "$current_session" ]]; then
      # Check if this session is in a worktree
      if is_session_in_worktree "$session"; then
        # Check if it has a matching tmuxinator config
        local session_dir
        session_dir=$(get_session_working_directory "$session")
        local matching_config
        matching_config=$(get_tmuxinator_for_worktree "$session_dir" "$tmuxinator_configs")

        if [[ -n "$matching_config" ]]; then
          # Green dot for tmuxinator session in worktree
          session_list+=("${GREEN}●${NC} $session")
        else
          # Blue dot for worktree session
          session_list+=("${BLUE}●${NC} $session")
        fi
      else
        # Regular green dot for non-worktree session
        session_list+=("${GREEN}●${NC} $session")
      fi
    fi
  done <<< "$active_sessions"

  # Add current session at the end of active sessions if it exists and not scratch
  if [[ -n "$current_session" ]] && ! echo "$current_session" | grep -q "scratch"; then
    # Check if current session is in a worktree
    if is_session_in_worktree "$current_session"; then
      local session_dir
      session_dir=$(get_session_working_directory "$current_session")
      local matching_config
      matching_config=$(get_tmuxinator_for_worktree "$session_dir" "$tmuxinator_configs")

      if [[ -n "$matching_config" ]]; then
        # Green arrow for current tmuxinator session in worktree
        session_list+=("${GREEN}→${NC} $current_session")
      else
        # Blue arrow for current worktree session
        session_list+=("${BLUE}→${NC} $current_session")
      fi
    else
      # Regular green arrow for current non-worktree session
      session_list+=("${GREEN}→${NC} $current_session")
    fi
  fi

  # Add git worktrees, excluding those already active or with matching working directories
  while IFS= read -r worktree; do
    if [[ -n "$worktree" ]] && ! echo "$active_sessions" | grep -q "^$worktree$" && ! echo "$scratch_sessions" | grep -q "^$worktree$"; then
      # Check if any active session is already running in this worktree's directory
      local worktree_path
      worktree_path=$(get_worktree_path "$worktree")
      if [[ -n "$worktree_path" ]] && ! is_worktree_path_active "$worktree_path" "$active_sessions"; then
        # Use empty blue circle for inactive worktree sessions
        session_list+=("${BLUE}○${NC} $worktree (worktree)")
      fi
    fi
  done <<< "$git_worktrees"

  # Add tmuxinator configs, excluding those already active
  while IFS= read -r config; do
    if [[ -n "$config" ]] && ! echo "$active_sessions" | grep -q "^$config$" && ! echo "$scratch_sessions" | grep -q "^$config$"; then
      session_list+=("${DARK_GREY}●${NC} $config (tmuxinator)")
    fi
  done <<< "$tmuxinator_configs"

  # Add scratch sessions at the bottom with special hidden icon
  while IFS= read -r session; do
    if [[ -n "$session" ]]; then
      if [[ "$session" == "$current_session" ]]; then
        session_list+=("${GREEN}→${NC} $session (scratch)")
      else
        session_list+=("${GREEN}󱗽${NC} $session (scratch)")
      fi
    fi
  done <<< "$scratch_sessions"

  printf '%s\n' "${session_list[@]}"
}

# Extract session name from selection
extract_session_name() {
  local selection="$1"
  echo "$selection" | sed -E 's/^[^●→○󱗽]*[●→○󱗽][^[:space:]]* ([^[:space:]]+).*/\1/'
}

# Check if session is active
is_session_active() {
  local session_name="$1"
  tmux has-session -t "$session_name" 2>/dev/null
}

# Kill session
kill_session() {
  local session_name="$1"
  if is_session_active "$session_name"; then
    tmux kill-session -t "$session_name" 2>/dev/null || true
  fi
}

# Rename session
rename_session() {
  local session_name="$1"
  if is_session_active "$session_name"; then
    tmux command-prompt -p "Rename session '$session_name' to:" \
      "rename-session -t '$session_name' '%%'" 2>/dev/null || true
  fi
}

# Create new session
create_new_session() {
  if [[ -n "${TMUX:-}" ]]; then
    # Create new session and switch to it
    local new_session_name
    new_session_name=$(tmux new-session -d -P -F "#{session_name}")
    tmux switch-client -t "$new_session_name" 2>/dev/null || true
  else
    tmux new-session
  fi
}

# Show help in preview area
show_help_preview() {
  cat << 'EOF'
Session Switcher Help

Keybindings:
  Enter    - Switch to session
  Ctrl-x   - Kill session
  Ctrl-r   - Rename session
  Ctrl-s   - Start in background
  Ctrl-n   - Create new session
  Ctrl-p   - Toggle preview
  Ctrl-d   - Page down in preview
  Ctrl-u   - Page up in preview
  ?        - Show help

Session Icons:
  ● - Active session (green)
  ● - Active worktree session (blue)
  → - Current session
  ● - Tmuxinator config (grey)
  ○ - Inactive worktree (blue outline)
  󱗽 - Scratch session

Navigation:
  ↑/↓ or j/k  - Move selection
  Esc         - Exit without selection
EOF
}

# Show help
show_help() {
  local help_text="Session Switcher Help:

Enter    - Switch to session
Ctrl-x   - Kill session
Ctrl-r   - Rename session
Ctrl-s   - Start in background
Ctrl-n   - Create new session
Ctrl-p   - Toggle preview
Esc      - Exit"
?        - Show this help

  if [[ -n "${TMUX:-}" ]]; then
    tmux display-popup -E -w 50% -h 40% "echo '$help_text'; echo ''; echo 'Press any key to continue...'; read -n1" 2>/dev/null || true
  else
    echo "$help_text"
    echo ""
    read -p "Press Enter to continue..." -r
  fi
}

# Start session without switching
start_session() {
  local session_name="$1"
  local selection="$2"

  if echo "$selection" | grep -q "(tmuxinator)"; then
    if command -v tmuxinator &> /dev/null; then
      tmuxinator start "$session_name" --no-attach 2>/dev/null || true
    fi
  fi
}

# Switch to or start session
switch_to_session() {
  local session_name="$1"
  local selection="$2"

  if is_session_active "$session_name"; then
    if [[ -n "${TMUX:-}" ]]; then
      tmux switch-client -t "$session_name"
    else
      tmux attach-session -t "$session_name"
    fi
  elif echo "$selection" | grep -q "(tmuxinator)"; then
    if command -v tmuxinator &> /dev/null; then
      tmuxinator start "$session_name"
      # Switch to the newly created session
      if [[ -n "${TMUX:-}" ]]; then
        tmux switch-client -t "$session_name" 2>/dev/null || true
      fi
    else
      echo "${RED}tmuxinator not found${NC}" >&2
      exit 1
    fi
  elif echo "$selection" | grep -q "(worktree)"; then
    local worktree_path
    worktree_path=$(get_worktree_path "$session_name")
    if [[ -n "$worktree_path" && -d "$worktree_path" ]]; then
      # Check if there's a matching tmuxinator config for this worktree
      local tmuxinator_configs
      tmuxinator_configs=$(get_tmuxinator_configs)
      local matching_config
      matching_config=$(get_tmuxinator_for_worktree "$worktree_path" "$tmuxinator_configs") || true

      if [[ -n "$matching_config" ]] && command -v tmuxinator &> /dev/null; then
        # Use tmuxinator if available
        tmuxinator start "$matching_config"
        if [[ -n "${TMUX:-}" ]]; then
          tmux switch-client -t "$matching_config" 2>/dev/null || true
        fi
      else
        # Create new session in the worktree directory
        if [[ -n "${TMUX:-}" ]]; then
          tmux new-session -d -s "$session_name" -c "$worktree_path"
          tmux switch-client -t "$session_name"
        else
          tmux new-session -s "$session_name" -c "$worktree_path"
        fi
      fi
    else
      echo "${RED}Worktree path not found for $session_name${NC}" >&2
      exit 1
    fi
  else
    echo "${RED}Unknown session type${NC}" >&2
    exit 1
  fi
}

# Main function
main() {
  check_dependencies

  local session_list
  session_list=$(build_session_list)

  if [[ -z "$session_list" ]]; then
    exit 0
  fi

  # Load preview preference
  local preview_enabled
  preview_enabled=$(load_preview_preference)

  # Set preview window options based on preference
  local preview_window_option="right:50%"
  if [[ "$preview_enabled" == "false" ]]; then
    preview_window_option="hidden"
  fi

  # Use fzf for selection (with tmux popup if inside tmux)
  local result
  if [[ -n "${TMUX:-}" ]]; then
    # Inside tmux - use popup with temporary files for input/output
    local input_file output_file preview_script
    input_file=$(mktemp)
    output_file=$(mktemp)
    preview_script=$(mktemp)
    echo "$session_list" > "$input_file"

    # Create preview script
    cat > "$preview_script" << 'EOF'
#!/bin/bash
source_script="$1"
selection="$2"
mode="$3"

source "$source_script"

# Handle different modes
case "$mode" in
  "HELP")
    show_help_preview
    ;;
  "PREVIEW")
    session_name=$(echo "$selection" | sed -E 's/^[^●→󱗽]*[●→󱗽][^[:space:]]* ([^[:space:]]+).*/\1/')
    generate_preview "$session_name" "$selection"
    ;;
  *)
    # Default to help
    show_help_preview
    ;;
esac
EOF
    chmod +x "$preview_script"

    # Determine initial preview state
    local initial_preview_visible="right:50%:wrap"
    if [[ "$preview_enabled" == "false" ]]; then
      initial_preview_visible="hidden"
    fi

    tmux display-popup -E -w 60% -h 40% \
      "cat '$input_file' | fzf --prompt='Select session (?: help): ' --ansi --reverse --border --expect=ctrl-x,ctrl-r,ctrl-s,ctrl-n,ctrl-p --preview='$preview_script \"$0\" {} PREVIEW' --preview-window=$initial_preview_visible --bind='ctrl-p:toggle-preview+change-preview($preview_script \"$0\" {} PREVIEW)+change-preview-window(right:50%:wrap)' --bind='?:change-preview($preview_script \"$0\" {} HELP)+change-preview-window(right:50%:wrap)' --bind='ctrl-d:preview-page-down' --bind='ctrl-u:preview-page-up' > '$output_file'" 2>/dev/null || true

    result=$(cat "$output_file" 2>/dev/null || true)
    rm -f "$input_file" "$output_file" "$preview_script"
  else
    # Outside tmux - regular fzf (no preview, only help)
    result=$(echo "$session_list" | fzf \
      --height=40% \
      --border \
      --prompt="Select session (?: help): " \
      --preview='echo -e "Session Switcher Help\n\nKeybindings:\n  Enter    - Switch to session\n  Ctrl-x   - Kill session\n  Ctrl-r   - Rename session\n  Ctrl-s   - Start in background\n  Ctrl-n   - Create new session\n  ?        - Toggle help\n\nSession Icons:\n  ● - Active session\n  → - Current session\n  ● - Tmuxinator config (grey)\n  ● - Git worktree (blue)\n  󱗽 - Scratch session\n\nNavigation:\n  ↑/↓ or j/k  - Move selection\n  Esc         - Exit without selection"' \
      --preview-window="hidden" \
      --ansi \
      --expect=ctrl-x,ctrl-r,ctrl-s,ctrl-n,ctrl-p \
      --bind='?:toggle-preview' 2>/dev/null || true)
  fi

  if [[ -n "$result" ]]; then
    local key
    local selection
    key=$(echo "$result" | head -n1)
    selection=$(echo "$result" | tail -n1)

    if [[ -n "$selection" ]]; then
      local session_name
      session_name=$(extract_session_name "$selection")

      case "$key" in
        "ctrl-x")
          kill_session "$session_name"
          # Restart the switcher to show updated list
          exec "$0" "$@"
          ;;
        "ctrl-r")
          rename_session "$session_name"
          # Restart the switcher to show updated list
          exec "$0" "$@"
          ;;
        "ctrl-s")
          start_session "$session_name" "$selection"
          # Restart the switcher to show updated list
          exec "$0" "$@"
          ;;
        "ctrl-n")
          create_new_session
          ;;
        "ctrl-p")
          # Toggle preview preference
          if [[ "$preview_enabled" == "true" ]]; then
            save_preview_preference "false"
          else
            save_preview_preference "true"
          fi
          # Restart the switcher with new preview setting
          exec "$0" "$@"
          ;;
        "")
          # Enter key - normal switch
          switch_to_session "$session_name" "$selection"
          ;;
      esac
    fi
  fi
}

# Handle command line arguments
if [[ "$1" == "--preview" ]]; then
  # Called as preview function
  selection="$2"
  session_name=$(extract_session_name "$selection")
  generate_preview "$session_name" "$selection"
  exit 0
elif [[ "$1" == "--help-preview" ]]; then
  # Called to show help in preview
  show_help_preview
  exit 0
fi

# Run if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
