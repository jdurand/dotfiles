#!/opt/homebrew/bin/bash

# tmux-session-manager: Comprehensive tmux session management with fuzzy finding
#
# Features:
# - Plugin-based architecture for extensible session types
# - Switch to active sessions (sorted by most recent, current session marked with →)
# - Kill sessions with Ctrl-x
# - Rename sessions with Ctrl-r
# - Start tmuxinator configs in background with Ctrl-s
# - Create new session with Ctrl-n
# - Toggle preview pane with Ctrl-p
# - Built-in help with ? key
# - Popup interface within tmux, regular fzf outside tmux
# - Plugin system for worktrees, tmuxinator, and future session types

set -e

# Configuration
readonly CONFIG_DIR="$HOME/.config/tmux-session-manager"
readonly CONFIG_FILE="$CONFIG_DIR/config"
readonly PLUGINS_DIR="$(dirname "${BASH_SOURCE[0]}")/tmux-session-manager-plugins"

# Colors for output
readonly RED=$'\033[0;31m'
readonly GREEN=$'\033[1;32m'
readonly YELLOW=$'\033[1;33m'
readonly BLUE=$'\033[0;34m'
readonly DARK_GREY=$'\033[0;90m'
readonly NC=$'\033[0m' # No Color

# Performance optimization: Use arrays instead of associative arrays for wider compatibility
PLUGINS_LIST=()
PLUGIN_ERRORS_LIST=()

# Load/save preview preference
load_preview_preference() {
  if [[ -f "$CONFIG_FILE" ]]; then
    source "$CONFIG_FILE" 2>/dev/null || true
  fi
  # Default to enabled if not set
  echo "${PREVIEW_ENABLED:-true}"
}

save_preview_preference() {
  local enabled="$1"
  mkdir -p "$CONFIG_DIR"
  echo "PREVIEW_ENABLED=$enabled" > "$CONFIG_FILE"
}

# Fast plugin loading with caching
load_plugins() {
  if [[ ! -d "$PLUGINS_DIR" ]]; then
    echo "ERROR: Plugins directory not found: $PLUGINS_DIR" >&2
    return 1
  fi

  PLUGINS_LIST=()
  PLUGIN_ERRORS_LIST=()

  for plugin_file in "$PLUGINS_DIR"/*.sh; do
    if [[ -f "$plugin_file" ]]; then
      local plugin_name
      plugin_name=$(basename "$plugin_file" .sh)

      # Quick dependency check without sourcing the whole plugin
      local depends=""
      if depends=$(grep "echo \"depends:" "$plugin_file" 2>/dev/null | head -1 | cut -d: -f2 | tr -d '"'); then
        if [[ -n "$depends" ]] && ! command -v "$depends" &>/dev/null; then
          local install_cmd
          install_cmd=$(grep "echo \"install_cmd:" "$plugin_file" 2>/dev/null | head -1 | cut -d: -f2- | tr -d '"')
          PLUGIN_ERRORS_LIST+=("$plugin_name:Missing dependency: $depends. Install with: $install_cmd")
          continue
        fi
      fi

      PLUGINS_LIST+=("$plugin_name:$plugin_file")
    fi
  done
}

# Fast plugin function calls without repeated sourcing
call_plugin_function_fast() {
  local plugin_name="$1"
  local function_name="$2"
  shift 2

  for plugin_entry in "${PLUGINS_LIST[@]}"; do
    if [[ "$plugin_entry" == "$plugin_name:"* ]]; then
      local plugin_file="${plugin_entry#*:}"
      source "$plugin_file" 2>/dev/null || return 1
      if declare -f "plugin_$function_name" >/dev/null 2>&1; then
        "plugin_$function_name" "$@"
        return $?
      else
        return 1
      fi
    fi
  done
  return 1
}

# Optimized session list building with minimal plugin calls
build_session_list_fast() {
  local session_list=()
  local current_session=""

  # Get current session if inside tmux
  if [[ -n "${TMUX:-}" ]]; then
    current_session=$(tmux display-message -p "#{session_name}")
  fi

  # Get base session data once
  local active_sessions scratch_sessions
  active_sessions=$(tmux list-sessions -F "#{session_last_attached}:#{session_name}" 2>/dev/null | grep -v ":.*scratch.*$" | sort -rn | cut -d: -f2 || true)
  scratch_sessions=$(tmux list-sessions -F "#{session_last_attached}:#{session_name}" 2>/dev/null | grep ":.*scratch.*$" | sort -rn | cut -d: -f2 || true)

  # Process plugins in priority order (hardcoded for performance)
  local plugins_order=("active:1" "worktree:10" "tmuxinator:20" "scratch:100")

  for plugin_entry in "${plugins_order[@]}"; do
    local plugin_name="${plugin_entry%:*}"

    # Skip if plugin has errors
    local has_error=false
    for error_entry in "${PLUGIN_ERRORS_LIST[@]}"; do
      if [[ "$error_entry" == "$plugin_name:"* ]]; then
        has_error=true
        break
      fi
    done
    if [[ "$has_error" == "true" ]]; then
      continue
    fi

    # Call plugin discover function
    local plugin_sessions
    case "$plugin_name" in
      "active")
        # Inline active session logic for performance
        while IFS= read -r session; do
          if [[ -n "$session" && "$session" != "$current_session" ]]; then
            # Check if in worktree for color
            local indicator="${GREEN}●${NC}"
            if [[ -f "$(tmux display-message -t "$session" -p "#{pane_current_path}" 2>/dev/null)/.git" ]] 2>/dev/null; then
              if grep -q "gitdir:" "$(tmux display-message -t "$session" -p "#{pane_current_path}" 2>/dev/null)/.git" 2>/dev/null; then
                indicator="${BLUE}●${NC}"
              fi
            fi
            session_list+=("$indicator $session")
          fi
        done <<< "$active_sessions"

        # Add current session
        if [[ -n "$current_session" ]] && ! echo "$current_session" | grep -q "scratch"; then
          local indicator="${GREEN}→${NC}"
          if [[ -f "$(tmux display-message -t "$current_session" -p "#{pane_current_path}" 2>/dev/null)/.git" ]] 2>/dev/null; then
            if grep -q "gitdir:" "$(tmux display-message -t "$current_session" -p "#{pane_current_path}" 2>/dev/null)/.git" 2>/dev/null; then
              indicator="${BLUE}→${NC}"
            fi
          fi
          session_list+=("$indicator $current_session")
        fi
        ;;
      "worktree")
        # Inline worktree logic for performance
        plugin_sessions=$(call_plugin_function_fast "$plugin_name" "discover" "$active_sessions" "$scratch_sessions" "$current_session" 2>/dev/null || true)
        if [[ -n "$plugin_sessions" ]]; then
          while IFS= read -r session_name; do
            if [[ -n "$session_name" ]]; then
              session_list+=("${BLUE}○${NC} $session_name (worktree)")
            fi
          done <<< "$plugin_sessions"
        fi
        ;;
      "tmuxinator")
        # Inline tmuxinator logic for performance
        if [[ -d "$HOME/.dotfiles/tmuxinator" ]]; then
          while IFS= read -r config; do
            if [[ -n "$config" ]] && ! echo "$active_sessions" | grep -q "^$config$" && ! echo "$scratch_sessions" | grep -q "^$config$"; then
              session_list+=("${DARK_GREY}●${NC} $config (tmuxinator)")
            fi
          done <<< "$(find "$HOME/.dotfiles/tmuxinator" -name "*.yml" -exec basename {} .yml \; 2>/dev/null | grep -v config || true)"
        fi
        ;;
      "scratch")
        # Inline scratch logic for performance
        while IFS= read -r session; do
          if [[ -n "$session" ]]; then
            if [[ "$session" == "$current_session" ]]; then
              session_list+=("${GREEN}→${NC} $session (scratch)")
            else
              session_list+=("${GREEN}󱗽${NC} $session (scratch)")
            fi
          fi
        done <<< "$scratch_sessions"
        ;;
    esac
  done

  printf '%s\n' "${session_list[@]}"
}

# Fast preview generation without plugin loading overhead
generate_preview_fast() {
  local session_name="$1"
  local selection="$2"

  # Direct preview logic based on session type for performance
  if echo "$selection" | grep -q "(tmuxinator)"; then
    echo "${BLUE}Tmuxinator Configuration: $session_name${NC}"
    echo ""
    if [[ -f "$HOME/.dotfiles/tmuxinator/$session_name.yml" ]]; then
      echo "${YELLOW}Configuration file:${NC}"
      echo "$HOME/.dotfiles/tmuxinator/$session_name.yml"
      echo ""
      echo "${YELLOW}Config preview:${NC}"
      head -20 "$HOME/.dotfiles/tmuxinator/$session_name.yml" 2>/dev/null | sed 's/^/  /' || echo "  Could not read config file"
    else
      echo "Configuration file not found"
    fi
    return
  fi

  if echo "$selection" | grep -q "(worktree)"; then
    echo "${BLUE}Git Worktree: $session_name${NC}"
    echo ""
    # Find worktree path quickly
    local worktree_path=""
    if git rev-parse --git-dir &>/dev/null; then
      worktree_path=$(git worktree list --porcelain 2>/dev/null | awk '/^worktree/ {path = $2} /^branch/ {print path}' | while read path; do if [[ "$(basename "$path")" == "$session_name" ]]; then echo "$path"; break; fi; done)
    fi

    if [[ -z "$worktree_path" ]]; then
      # Check from active sessions
      local active_sessions
      active_sessions=$(tmux list-sessions -F "#{session_name}" 2>/dev/null | grep -v "scratch" || true)
      while IFS= read -r session; do
        if [[ -n "$session" ]]; then
          local session_dir
          session_dir=$(tmux display-message -t "$session" -p "#{pane_current_path}" 2>/dev/null)
          if [[ -n "$session_dir" && -d "$session_dir" ]]; then
            worktree_path=$(cd "$session_dir" 2>/dev/null && git worktree list --porcelain 2>/dev/null | awk '/^worktree/ {path = $2} /^branch/ {print path}' | while read path; do if [[ "$(basename "$path")" == "$session_name" ]]; then echo "$path"; break; fi; done)
            if [[ -n "$worktree_path" ]]; then
              break
            fi
          fi
        fi
      done <<< "$active_sessions"
    fi

    if [[ -n "$worktree_path" && -d "$worktree_path" ]]; then
      echo "${YELLOW}Worktree path:${NC}"
      echo "$worktree_path"
      echo ""
      if cd "$worktree_path" 2>/dev/null; then
        echo "${YELLOW}Branch info:${NC}"
        git branch --show-current 2>/dev/null || echo "  Could not determine branch"
        echo ""
        echo "${YELLOW}Recent commits:${NC}"
        git log --oneline -5 2>/dev/null | sed 's/^/  /' || echo "  Could not read git log"
      fi
    else
      echo "Worktree path not found"
    fi
    return
  fi

  # Active session preview
  if ! tmux has-session -t "$session_name" 2>/dev/null; then
    echo "${RED}Session '$session_name' is not active${NC}"
    echo ""
    echo "This session will be created when selected."
    return
  fi

  # Live session preview
  local active_window
  active_window=$(tmux list-windows -t "$session_name" -f '#{window_active}' -F "#{window_index}" 2>/dev/null | head -1)

  if [[ -n "$active_window" ]]; then
    local active_pane
    active_pane=$(tmux list-panes -t "$session_name:$active_window" -f '#{pane_active}' -F "#{pane_index}" 2>/dev/null | head -1)

    if [[ -n "$active_pane" ]]; then
      local window_count
      window_count=$(tmux list-windows -t "$session_name" 2>/dev/null | wc -l | tr -d ' ')
      echo "${GREEN}● $session_name${NC} (${YELLOW}${window_count} windows${NC})"
      echo "${DARK_GREY}────────────────────────────────────────${NC}"

      tmux capture-pane -ep -t "$session_name:$active_window.$active_pane" 2>/dev/null || {
        echo "${RED}Could not capture session content${NC}"
        echo "Session may be busy or inaccessible"
      }
    fi
  fi
}

# Extract session name and type from selection
extract_session_info() {
  local selection="$1"

  # Extract session name
  local session_name
  session_name=$(echo "$selection" | sed -E 's/^[^●→○󱗽]*[●→○󱗽][^[:space:]]* ([^[:space:]]+).*/\1/')

  # Extract session type
  local session_type="active"
  if echo "$selection" | grep -q "(tmuxinator)"; then
    session_type="tmuxinator"
  elif echo "$selection" | grep -q "(worktree)"; then
    session_type="worktree"
  elif echo "$selection" | grep -q "(scratch)"; then
    session_type="scratch"
  fi

  echo "$session_name:$session_type"
}

# Fast session switching
switch_to_session_fast() {
  local session_name="$1"
  local selection="$2"

  local session_info
  session_info=$(extract_session_info "$selection")
  local session_type="${session_info#*:}"
  session_name="${session_info%:*}"

  case "$session_type" in
    "active"|"scratch")
      if [[ -n "${TMUX:-}" ]]; then
        tmux switch-client -t "$session_name"
      else
        tmux attach-session -t "$session_name"
      fi
      ;;
    "tmuxinator")
      if ! command -v tmuxinator &> /dev/null; then
        echo "${RED}tmuxinator command not found${NC}" >&2
        exit 1
      fi
      tmuxinator start "$session_name"
      if [[ -n "${TMUX:-}" ]]; then
        tmux switch-client -t "$session_name" 2>/dev/null || true
      fi
      ;;
    "worktree")
      # Fast worktree switching
      local worktree_path=""
      if git rev-parse --git-dir &>/dev/null; then
        worktree_path=$(git worktree list --porcelain 2>/dev/null | awk '/^worktree/ {path = $2} /^branch/ {print path}' | while read path; do if [[ "$(basename "$path")" == "$session_name" ]]; then echo "$path"; break; fi; done)
      fi

      if [[ -z "$worktree_path" ]]; then
        # Check from active sessions
        local active_sessions
        active_sessions=$(tmux list-sessions -F "#{session_name}" 2>/dev/null | grep -v "scratch" || true)
        while IFS= read -r session; do
          if [[ -n "$session" ]]; then
            local session_dir
            session_dir=$(tmux display-message -t "$session" -p "#{pane_current_path}" 2>/dev/null)
            if [[ -n "$session_dir" && -d "$session_dir" ]]; then
              worktree_path=$(cd "$session_dir" 2>/dev/null && git worktree list --porcelain 2>/dev/null | awk '/^worktree/ {path = $2} /^branch/ {print path}' | while read path; do if [[ "$(basename "$path")" == "$session_name" ]]; then echo "$path"; break; fi; done)
              if [[ -n "$worktree_path" ]]; then
                break
              fi
            fi
          fi
        done <<< "$active_sessions"
      fi

      if [[ -n "$worktree_path" && -d "$worktree_path" ]]; then
        # Check for tmuxinator config
        if [[ -d "$HOME/.dotfiles/tmuxinator" ]]; then
          local matching_config=""
          for config_file in "$HOME/.dotfiles/tmuxinator"/*.yml; do
            if [[ -f "$config_file" ]]; then
              local config_root
              config_root=$(grep "^root:" "$config_file" 2>/dev/null | sed 's/^root: *//' | tr -d '"' | head -1)
              config_root="${config_root/#\~/$HOME}"
              if [[ "$config_root" == "$worktree_path" ]]; then
                matching_config=$(basename "$config_file" .yml)
                break
              fi
            fi
          done

          if [[ -n "$matching_config" ]] && command -v tmuxinator &> /dev/null; then
            tmuxinator start "$matching_config"
            if [[ -n "${TMUX:-}" ]]; then
              tmux switch-client -t "$matching_config" 2>/dev/null || true
            fi
            return
          fi
        fi

        # Create basic session
        if [[ -n "${TMUX:-}" ]]; then
          tmux new-session -d -s "$session_name" -c "$worktree_path"
          tmux switch-client -t "$session_name"
        else
          tmux new-session -s "$session_name" -c "$worktree_path"
        fi
      else
        echo "${RED}Worktree path not found for $session_name${NC}" >&2
        exit 1
      fi
      ;;
  esac
}

# Optimized kill/rename functions
kill_session_fast() {
  local selection="$1"
  local session_info
  session_info=$(extract_session_info "$selection")
  local session_name="${session_info%:*}"

  if tmux has-session -t "$session_name" 2>/dev/null; then
    tmux kill-session -t "$session_name" 2>/dev/null || true
  fi
}

rename_session_fast() {
  local selection="$1"
  local session_info
  session_info=$(extract_session_info "$selection")
  local session_name="${session_info%:*}"

  if tmux has-session -t "$session_name" 2>/dev/null; then
    tmux command-prompt -p "Rename session '$session_name' to:" \
      "rename-session -t '$session_name' '%%'" 2>/dev/null || true
  fi
}

start_session_fast() {
  local selection="$1"
  local session_info
  session_info=$(extract_session_info "$selection")
  local session_type="${session_info#*:}"
  local session_name="${session_info%:*}"

  if [[ "$session_type" == "tmuxinator" ]] && command -v tmuxinator &> /dev/null; then
    tmuxinator start "$session_name" --no-attach 2>/dev/null || true
  fi
}

# Create new session
create_new_session() {
  if [[ -n "${TMUX:-}" ]]; then
    local new_session_name
    new_session_name=$(tmux new-session -d -P -F "#{session_name}")
    tmux switch-client -t "$new_session_name" 2>/dev/null || true
  else
    tmux new-session
  fi
}

# Show help in preview area
show_help_preview() {
  cat << 'EOF'
Session Switcher Help

Keybindings:
  Enter    - Switch to session
  Ctrl-x   - Kill session
  Ctrl-r   - Rename session
  Ctrl-s   - Start in background
  Ctrl-n   - Create new session
  Ctrl-p   - Toggle preview
  Ctrl-d   - Page down in preview
  Ctrl-u   - Page up in preview
  ?        - Show help

Session Icons:
  ● - Active session (green)
  ● - Active worktree session (blue)
  → - Current session
  ● - Tmuxinator config (grey)
  ○ - Inactive worktree (blue outline)
  󱗽 - Scratch session

Navigation:
  ↑/↓ or j/k  - Move selection
  Esc         - Exit without selection

Additional Commands:
  --doctor - Check plugin health
EOF
}

# Session info and troubleshooting mode
debug_mode() {
  echo "tmux-session-manager info"
  echo "========================="
  echo

  echo "Environment:"
  echo "------------"
  echo "Current tmux session: $(tmux display-message -p '#{session_name}' 2>/dev/null || echo 'NOT IN TMUX')"
  echo "Working directory: $(pwd)"
  echo "Bash version: $BASH_VERSION"
  echo

  echo "Plugin loading:"
  echo "---------------"
  load_plugins
  echo "Plugins loaded: ${#PLUGINS_LIST[@]}"
  for plugin_entry in "${PLUGINS_LIST[@]}"; do
    local plugin_name="${plugin_entry%:*}"
    echo "  ✓ $plugin_name"
  done
  echo

  echo "Session generation:"
  echo "------------------"
  local session_list
  session_list=$(build_session_list_fast)
  
  echo "Session count: $(echo "$session_list" | wc -l | tr -d ' ')"
  local worktree_count tmuxinator_count scratch_count active_count
  set +e  # Temporarily disable exit on error for counting
  worktree_count=$(echo "$session_list" | grep -c "(worktree)" 2>/dev/null)
  active_count=$(echo "$session_list" | grep -c "^\[1;32m" 2>/dev/null)
  tmuxinator_count=$(echo "$session_list" | grep -c "(tmuxinator)" 2>/dev/null)
  scratch_count=$(echo "$session_list" | grep -c "(scratch)" 2>/dev/null)
  set -e  # Re-enable exit on error
  echo "Worktree sessions: $worktree_count"
  echo "Active sessions: $active_count"
  echo "Tmuxinator configs: $tmuxinator_count"
  echo "Scratch sessions: $scratch_count"
  echo
  
  echo "Full session list:"
  echo "$session_list"
  echo

  if echo "$session_list" | grep -q "(worktree)"; then
    echo "${GREEN}✓${NC} Worktree sessions found:"
    echo "$session_list" | grep "(worktree)" | sed 's/^/  /'
  else
    echo "${RED}✗${NC} No worktree sessions found"
    
    echo
    echo "Worktree troubleshooting:"
    echo "------------------------"
    local active_sessions scratch_sessions current_session
    active_sessions=$(tmux list-sessions -F "#{session_last_attached}:#{session_name}" 2>/dev/null | grep -v ":.*scratch.*$" | sort -rn | cut -d: -f2 || true)
    scratch_sessions=$(tmux list-sessions -F "#{session_last_attached}:#{session_name}" 2>/dev/null | grep ":.*scratch.*$" | sort -rn | cut -d: -f2 || true)
    if [[ -n "${TMUX:-}" ]]; then
      current_session=$(tmux display-message -p "#{session_name}")
    fi

    local worktree_result
    worktree_result=$(call_plugin_function_fast worktree discover "$active_sessions" "$scratch_sessions" "$current_session" 2>&1)
    echo "Direct worktree plugin result: '$worktree_result'"
  fi
}

# Doctor command - check plugin health by reading actual plugin files
doctor() {
  echo "tmux-session-manager doctor"
  echo "=========================="
  echo

  echo "Plugin Status:"
  echo "--------------"

  # Load plugins to check their health
  load_plugins

  local all_dependencies=("tmux" "fzf")  # Core dependencies
  local plugin_count=0
  local error_count=0

  if [[ ${#PLUGINS_LIST[@]} -eq 0 ]]; then
    echo "${RED}No plugins loaded${NC}"
    error_count=1
  else
    # Check each plugin
    for plugin_entry in "${PLUGINS_LIST[@]}"; do
      local plugin_name="${plugin_entry%:*}"
      local plugin_file="${plugin_entry#*:}"
      plugin_count=$((plugin_count + 1))

      # Get plugin metadata by sourcing the plugin file
      if source "$plugin_file" 2>/dev/null; then
        local meta
        if meta=$(plugin_meta 2>/dev/null); then
          local description depends install_cmd
          description=$(echo "$meta" | grep "^description:" | cut -d: -f2-)
          depends=$(echo "$meta" | grep "^depends:" | cut -d: -f2)
          install_cmd=$(echo "$meta" | grep "^install_cmd:" | cut -d: -f2-)

          # Add to all dependencies list
          if [[ -n "$depends" ]]; then
            all_dependencies+=("$depends")
          fi

          # Check if dependency is available
          if [[ -n "$depends" ]] && ! command -v "$depends" &>/dev/null; then
            echo "${RED}✗ $plugin_name${NC}: Missing dependency: $depends. Install with: $install_cmd"
            error_count=$((error_count + 1))
          else
            echo "${GREEN}✓ $plugin_name${NC}: $description"
          fi
        else
          echo "${RED}✗ $plugin_name${NC}: Plugin metadata function failed"
          error_count=$((error_count + 1))
        fi
      else
        echo "${RED}✗ $plugin_name${NC}: Failed to load plugin file"
        error_count=$((error_count + 1))
      fi
    done

    # Check plugin errors from load_plugins
    for error_entry in "${PLUGIN_ERRORS_LIST[@]}"; do
      local plugin_name="${error_entry%:*}"
      local error_msg="${error_entry#*:}"
      echo "${RED}✗ $plugin_name${NC}: $error_msg"
      error_count=$((error_count + 1))
    done
  fi

  echo
  echo "System Dependencies:"
  echo "-------------------"

  # Remove duplicates from all_dependencies and check each one
  local -a unique_deps
  for dep in "${all_dependencies[@]}"; do
    local found=false
    for unique_dep in "${unique_deps[@]}"; do
      if [[ "$dep" == "$unique_dep" ]]; then
        found=true
        break
      fi
    done
    if [[ "$found" == "false" ]]; then
      unique_deps+=("$dep")
    fi
  done

  for dep in "${unique_deps[@]}"; do
    if command -v "$dep" &>/dev/null; then
      echo "${GREEN}✓ $dep${NC}: $(command -v "$dep")"
    else
      echo "${RED}✗ $dep${NC}: not found"
    fi
  done

  echo
  echo "Summary:"
  echo "--------"
  echo "Plugins loaded: $plugin_count"
  if [[ $error_count -eq 0 ]]; then
    echo "${GREEN}All systems operational!${NC}"
  else
    echo "${RED}Found $error_count issue(s) that may affect functionality${NC}"
  fi
}

# Check dependencies
check_dependencies() {
  local deps=("tmux" "fzf")
  local missing=()

  for dep in "${deps[@]}"; do
    if ! command -v "$dep" &> /dev/null; then
      missing+=("$dep")
    fi
  done

  if [[ ${#missing[@]} -gt 0 ]]; then
    echo -e "${RED}Missing dependencies: ${missing[*]}${NC}" >&2
    echo "Run 'tmux-session-manager --doctor' for more information" >&2
    exit 1
  fi
}

# Build error title for plugin failures (simplified)
build_error_title() {
  local error_count=0
  local deps=("tmuxinator" "git")
  for dep in "${deps[@]}"; do
    if ! command -v "$dep" &>/dev/null; then
      ((error_count++))
    fi
  done

  if [[ $error_count -gt 0 ]]; then
    echo " [missing $error_count dependencies]"
  fi
}

# Main function
main() {
  load_plugins
  check_dependencies

  local session_list
  session_list=$(build_session_list_fast)

  if [[ -z "$session_list" ]]; then
    exit 0
  fi

  # Load preview preference
  local preview_enabled
  preview_enabled=$(load_preview_preference)

  # Build title with potential error information
  local title="Select session (?: help)"
  local error_suffix
  error_suffix=$(build_error_title)
  if [[ -n "$error_suffix" ]]; then
    title="$title$error_suffix"
  fi

  # Use fzf for selection (with tmux popup if inside tmux)
  local result
  if [[ -n "${TMUX:-}" && -z "${FORCE_NO_POPUP:-}" ]]; then
    # Inside tmux - use popup with temporary files for input/output
    local input_file output_file preview_script
    input_file=$(mktemp)
    output_file=$(mktemp)
    preview_script=$(mktemp)
    echo "$session_list" > "$input_file"

    # Create optimized preview script using the same bash
    cat > "$preview_script" << 'EOF'
#!/opt/homebrew/bin/bash
source_script="$1"
selection="$2"
mode="$3"

# Colors for output (copied to avoid sourcing main script)
readonly RED=$'\033[0;31m'
readonly GREEN=$'\033[1;32m'
readonly YELLOW=$'\033[1;33m'
readonly BLUE=$'\033[0;34m'
readonly DARK_GREY=$'\033[0;90m'
readonly NC=$'\033[0m'

# Show help in preview area
show_help_preview() {
  cat << 'HELP_EOF'
Session Switcher Help

Keybindings:
  Enter    - Switch to session
  Ctrl-x   - Kill session
  Ctrl-r   - Rename session
  Ctrl-s   - Start in background
  Ctrl-n   - Create new session
  Ctrl-p   - Toggle preview
  Ctrl-d   - Page down in preview
  Ctrl-u   - Page up in preview
  ?        - Show help

Session Icons:
  ● - Active session (green)
  ● - Active worktree session (blue)
  → - Current session
  ● - Tmuxinator config (grey)
  ○ - Inactive worktree (blue outline)
  󱗽 - Scratch session

Navigation:
  ↑/↓ or j/k  - Move selection
  Esc         - Exit without selection

Additional Commands:
  --doctor - Check plugin health
HELP_EOF
}

# Fast preview generation
generate_preview_fast() {
  local session_name="$1"
  local selection="$2"

  # Direct preview logic based on session type for performance
  if echo "$selection" | grep -q "(tmuxinator)"; then
    echo "${BLUE}Tmuxinator Configuration: $session_name${NC}"
    echo ""
    if [[ -f "$HOME/.dotfiles/tmuxinator/$session_name.yml" ]]; then
      echo "${YELLOW}Configuration file:${NC}"
      echo "$HOME/.dotfiles/tmuxinator/$session_name.yml"
      echo ""
      echo "${YELLOW}Config preview:${NC}"
      head -20 "$HOME/.dotfiles/tmuxinator/$session_name.yml" 2>/dev/null | sed 's/^/  /' || echo "  Could not read config file"
    else
      echo "Configuration file not found"
    fi
    return
  fi

  if echo "$selection" | grep -q "(worktree)"; then
    echo "${BLUE}Git Worktree: $session_name${NC}"
    echo ""
    # Find worktree path quickly
    local worktree_path=""
    if git rev-parse --git-dir &>/dev/null; then
      worktree_path=$(git worktree list --porcelain 2>/dev/null | awk '/^worktree/ {path = $2} /^branch/ {print path}' | while read path; do if [[ "$(basename "$path")" == "$session_name" ]]; then echo "$path"; break; fi; done)
    fi

    if [[ -z "$worktree_path" ]]; then
      # Check from active sessions
      local active_sessions
      active_sessions=$(tmux list-sessions -F "#{session_name}" 2>/dev/null | grep -v "scratch" || true)
      while IFS= read -r session; do
        if [[ -n "$session" ]]; then
          local session_dir
          session_dir=$(tmux display-message -t "$session" -p "#{pane_current_path}" 2>/dev/null)
          if [[ -n "$session_dir" && -d "$session_dir" ]]; then
            worktree_path=$(cd "$session_dir" 2>/dev/null && git worktree list --porcelain 2>/dev/null | awk '/^worktree/ {path = $2} /^branch/ {print path}' | while read path; do if [[ "$(basename "$path")" == "$session_name" ]]; then echo "$path"; break; fi; done)
            if [[ -n "$worktree_path" ]]; then
              break
            fi
          fi
        fi
      done <<< "$active_sessions"
    fi

    if [[ -n "$worktree_path" && -d "$worktree_path" ]]; then
      echo "${YELLOW}Worktree path:${NC}"
      echo "$worktree_path"
      echo ""
      if cd "$worktree_path" 2>/dev/null; then
        echo "${YELLOW}Branch info:${NC}"
        git branch --show-current 2>/dev/null || echo "  Could not determine branch"
        echo ""
        echo "${YELLOW}Recent commits:${NC}"
        git log --oneline -5 2>/dev/null | sed 's/^/  /' || echo "  Could not read git log"
      fi
    else
      echo "Worktree path not found"
    fi
    return
  fi

  # Active session preview
  if ! tmux has-session -t "$session_name" 2>/dev/null; then
    echo "${RED}Session '$session_name' is not active${NC}"
    echo ""
    echo "This session will be created when selected."
    return
  fi

  # Live session preview
  local active_window
  active_window=$(tmux list-windows -t "$session_name" -f '#{window_active}' -F "#{window_index}" 2>/dev/null | head -1)

  if [[ -n "$active_window" ]]; then
    local active_pane
    active_pane=$(tmux list-panes -t "$session_name:$active_window" -f '#{pane_active}' -F "#{pane_index}" 2>/dev/null | head -1)

    if [[ -n "$active_pane" ]]; then
      local window_count
      window_count=$(tmux list-windows -t "$session_name" 2>/dev/null | wc -l | tr -d ' ')
      echo "${GREEN}● $session_name${NC} (${YELLOW}${window_count} windows${NC})"
      echo "${DARK_GREY}────────────────────────────────────────${NC}"

      tmux capture-pane -ep -t "$session_name:$active_window.$active_pane" 2>/dev/null || {
        echo "${RED}Could not capture session content${NC}"
        echo "Session may be busy or inaccessible"
      }
    fi
  fi
}

case "$mode" in
  "HELP")
    show_help_preview
    ;;
  "PREVIEW")
    session_name=$(echo "$selection" | sed -E 's/^[^●→○󱗽]*[●→○󱗽][^[:space:]]* ([^[:space:]]+).*/\1/')
    generate_preview_fast "$session_name" "$selection"
    ;;
  *)
    show_help_preview
    ;;
esac
EOF
    chmod +x "$preview_script"

    # Determine initial preview state
    local initial_preview_visible="right:50%:wrap"
    if [[ "$preview_enabled" == "false" ]]; then
      initial_preview_visible="hidden"
    fi

    tmux display-popup -E -w 60% -h 40% \
      "cat '$input_file' | fzf --prompt='$title: ' --ansi --reverse --border --expect=ctrl-x,ctrl-r,ctrl-s,ctrl-n,ctrl-p --preview='$preview_script \"$0\" {} PREVIEW' --preview-window=$initial_preview_visible --bind='ctrl-p:toggle-preview+change-preview($preview_script \"$0\" {} PREVIEW)+change-preview-window(right:50%:wrap)' --bind='?:change-preview($preview_script \"$0\" {} HELP)+change-preview-window(right:50%:wrap)' --bind='ctrl-d:preview-page-down' --bind='ctrl-u:preview-page-up' > '$output_file'" 2>/dev/null || true

    result=$(cat "$output_file" 2>/dev/null || true)
    rm -f "$input_file" "$output_file" "$preview_script"
  else
    # Outside tmux - regular fzf
    result=$(echo "$session_list" | fzf \
      --height=40% \
      --border \
      --prompt="$title: " \
      --preview='echo -e "Session Switcher Help\n\nKeybindings:\n  Enter    - Switch to session\n  Ctrl-x   - Kill session\n  Ctrl-r   - Rename session\n  Ctrl-s   - Start in background\n  Ctrl-n   - Create new session\n  ?        - Toggle help\n\nSession Icons:\n  ● - Active session\n  → - Current session\n  ● - Tmuxinator config (grey)\n  ● - Git worktree (blue)\n  󱗽 - Scratch session\n\nNavigation:\n  ↑/↓ or j/k  - Move selection\n  Esc         - Exit without selection"' \
      --preview-window="hidden" \
      --ansi \
      --expect=ctrl-x,ctrl-r,ctrl-s,ctrl-n,ctrl-p \
      --bind='?:toggle-preview' 2>/dev/null || true)
  fi

  if [[ -n "$result" ]]; then
    local key
    local selection
    key=$(echo "$result" | head -n1)
    selection=$(echo "$result" | tail -n1)

    if [[ -n "$selection" ]]; then
      case "$key" in
        "ctrl-x")
          kill_session_fast "$selection"
          exec "$0" "$@"
          ;;
        "ctrl-r")
          rename_session_fast "$selection"
          exec "$0" "$@"
          ;;
        "ctrl-s")
          start_session_fast "$selection"
          exec "$0" "$@"
          ;;
        "ctrl-n")
          create_new_session
          ;;
        "ctrl-p")
          if [[ "$preview_enabled" == "true" ]]; then
            save_preview_preference "false"
          else
            save_preview_preference "true"
          fi
          exec "$0" "$@"
          ;;
        "")
          switch_to_session_fast "" "$selection"
          ;;
      esac
    fi
  fi
}

# Handle command line arguments
case "${1:-}" in
  "--doctor")
    doctor
    exit 0
    ;;
  "--info")
    debug_mode
    exit 0
    ;;
  "--no-popup")
    FORCE_NO_POPUP=1
    main "$@"
    ;;
  "--preview")
    # Called as preview function (legacy support)
    selection="$2"
    session_name=$(echo "$selection" | sed -E 's/^[^●→○󱗽]*[●→○󱗽][^[:space:]]* ([^[:space:]]+).*/\1/')
    generate_preview_fast "$session_name" "$selection"
    exit 0
    ;;
  "--help-preview")
    show_help_preview
    exit 0
    ;;
  "--help"|"-h")
    echo "tmux-session-manager - Plugin-based tmux session manager"
    echo ""
    echo "Usage: $0 [options]"
    echo ""
    echo "Options:"
    echo "  --doctor           Check plugin health and dependencies"
    echo "  --info             Show session info and troubleshooting"
    echo "  --no-popup         Force regular fzf instead of tmux popup"
    echo "  --help, -h         Show this help message"
    echo ""
    echo "Interactive mode (default):"
    echo "  Run without arguments to open the session selector"
    exit 0
    ;;
  "")
    main "$@"
    ;;
  *)
    echo "Unknown option: $1" >&2
    echo "Use --help for usage information" >&2
    exit 1
    ;;
esac