#!/opt/homebrew/bin/bash

# tmux-session-manager: Comprehensive tmux session management with fuzzy finding
#
# Features:
# - Plugin-based architecture for extensible session types
# - Switch to active sessions (sorted by most recent, current session marked with →)
# - Kill sessions with Ctrl-x
# - Rename sessions with Ctrl-r
# - Start tmuxinator configs in background with Ctrl-s
# - Create new session with Ctrl-n
# - Toggle preview pane with Ctrl-p
# - Built-in help with ? key
# - Popup interface within tmux, regular fzf outside tmux
# - Plugin system for worktrees, tmuxinator, and future session types
#
# Plugin Priority System (lower number = higher priority):
# - Priority 5:   Worktree sessions (highest priority)
# - Priority 10:  Active tmux sessions
# - Priority 50:  Tmuxinator configuration sessions
# - Priority 100: Default for plugins without explicit sort_priority
# - Priority 999:  Scratch/temporary sessions
#
# Session Ordering:
# - 1. Most recent active session (always first for quick-switch)
# - 2. Sessions by plugin priority (0, 5, 10, 50, 100, 999...)
# - 3. Within same priority: sorted by last-attached timestamp
# - 4. Current session appears with → marker
# - 5. Scratch sessions always appear last (due to high priority)

set -e

# Configuration
readonly CONFIG_DIR="$HOME/.config/tmux-session-manager"
readonly CONFIG_FILE="$CONFIG_DIR/config"
readonly PLUGINS_DIR="$(dirname "${BASH_SOURCE[0]}")/plugins"
readonly CORE_DIR="$(dirname "${BASH_SOURCE[0]}")/core"

# Colors for output - full spectrum support
# Plugin developers can use these colors in plugin_meta() icon_color: or plugin_resolve() override_color:
# Rainbow: RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET
# Additional: PURPLE, PINK, CYAN, BRIGHT_CYAN, MAGENTA, BRIGHT_MAGENTA
# Neutrals: WHITE, BRIGHT_WHITE, GREY, DARK_GREY, BLACK, SILVER
# Bright variants: BRIGHT_RED, BRIGHT_GREEN, BRIGHT_YELLOW, BRIGHT_BLUE
# Special: GOLD (same as BRIGHT_YELLOW)
# Primary rainbow colors (conditional to avoid readonly conflicts)
[[ -z "${RED:-}" ]] && readonly RED=$'\033[0;31m'
[[ -z "${ORANGE:-}" ]] && readonly ORANGE=$'\033[0;33m'     # Using standard yellow as orange base
[[ -z "${YELLOW:-}" ]] && readonly YELLOW=$'\033[1;33m'
[[ -z "${GREEN:-}" ]] && readonly GREEN=$'\033[1;32m'
[[ -z "${BLUE:-}" ]] && readonly BLUE=$'\033[0;34m'
readonly INDIGO=$'\033[0;35m'     # Using magenta as indigo base
readonly VIOLET=$'\033[1;35m'     # Bright magenta as violet

# Additional colors
readonly PURPLE=$'\033[0;35m'
readonly PINK=$'\033[1;31m'       # Bright red as pink
readonly CYAN=$'\033[0;36m'
readonly BRIGHT_CYAN=$'\033[1;36m'
readonly MAGENTA=$'\033[0;35m'
readonly BRIGHT_MAGENTA=$'\033[1;35m'

# Greys and whites
readonly WHITE=$'\033[0;37m'
readonly BRIGHT_WHITE=$'\033[1;37m'
readonly GREY=$'\033[0;37m'
readonly DARK_GREY=$'\033[0;90m'
readonly BLACK=$'\033[0;30m'

# Bright variants of primary colors
readonly BRIGHT_RED=$'\033[1;31m'
readonly BRIGHT_GREEN=$'\033[1;32m'
readonly BRIGHT_YELLOW=$'\033[1;33m'
readonly BRIGHT_BLUE=$'\033[1;34m'

# Special theme colors
readonly GOLD=$'\033[1;33m'       # Same as bright yellow, semantic name
readonly SILVER=$'\033[0;37m'     # Same as grey, semantic name

[[ -z "${NC:-}" ]] && readonly NC=$'\033[0m' # No Color

# Performance optimization: Use arrays instead of associative arrays for wider compatibility
PLUGINS_LIST=()
PLUGIN_ERRORS_LIST=()
PLUGIN_METADATA_CACHE=()

# Load/save preview preference
load_preview_preference() {
  if [[ -f "$CONFIG_FILE" ]]; then
    source "$CONFIG_FILE" 2>/dev/null || true
  fi
  # Default to enabled if not set
  echo "${PREVIEW_ENABLED:-true}"
}

save_preview_preference() {
  local enabled="$1"
  mkdir -p "$CONFIG_DIR"
  echo "PREVIEW_ENABLED=$enabled" > "$CONFIG_FILE"
}

# Fast plugin loading with pre-loading for performance (core + regular plugins)
load_plugins() {
  PLUGINS_LIST=()
  PLUGIN_ERRORS_LIST=()

  # First pass: collect all plugin files with their priorities from both core and plugins directories
  local temp_plugins=()

  # Load core plugins first (if core directory exists)
  if [[ -d "$CORE_DIR" ]]; then
    for plugin_file in "$CORE_DIR"/*.sh; do
      [[ -f "$plugin_file" ]] && temp_plugins+=("$plugin_file")
    done
  fi

  # Then load regular plugins (if plugins directory exists)
  if [[ -d "$PLUGINS_DIR" ]]; then
    for plugin_file in "$PLUGINS_DIR"/*.sh; do
      [[ -f "$plugin_file" ]] && temp_plugins+=("$plugin_file")
    done
  fi

  # Process all collected plugin files and add priority data
  local plugin_priority_data=()
  for plugin_file in "${temp_plugins[@]}"; do
    if [[ -f "$plugin_file" ]]; then
      local plugin_name
      plugin_name=$(basename "$plugin_file" .sh)

      # Quick dependency check without sourcing the whole plugin
      local depends=""
      if depends=$(grep "echo \"depends:" "$plugin_file" 2>/dev/null | head -1 | cut -d: -f2 | tr -d '"'); then
        if [[ -n "$depends" ]] && ! command -v "$depends" &>/dev/null; then
          local install_cmd
          install_cmd=$(grep "echo \"install_cmd:" "$plugin_file" 2>/dev/null | head -1 | cut -d: -f2- | tr -d '"')
          PLUGIN_ERRORS_LIST+=("$plugin_name:Missing dependency: $depends. Install with: $install_cmd")
          continue
        fi
      fi

      # Get priority from plugin file
      local priority="100"  # Default priority
      if priority_line=$(grep "echo \"sort_priority:" "$plugin_file" 2>/dev/null | head -1); then
        priority=$(echo "$priority_line" | cut -d: -f2 | tr -d '"')
      fi

      # Store plugin with priority for sorting
      plugin_priority_data+=("$priority:$plugin_name:$plugin_file")
    fi
  done

  # Sort plugins by priority (lower number = higher priority)
  local sorted_plugins
  sorted_plugins=($(printf '%s\n' "${plugin_priority_data[@]}" | sort -n))

  # Second pass: load plugins in priority order
  for plugin_entry in "${sorted_plugins[@]}"; do
    local priority="${plugin_entry%%:*}"
    local remainder="${plugin_entry#*:}"
    local plugin_name="${remainder%%:*}"
    local plugin_file="${remainder#*:}"

    # Pre-load plugin by sourcing it once and cache metadata
    if source "$plugin_file" 2>/dev/null; then
      # Cache plugin metadata during loading for performance
      local icon="●" icon_color="GREEN" description=""
      if declare -f "plugin_meta" >/dev/null 2>&1; then
        local plugin_meta_output
        if plugin_meta_output=$(plugin_meta 2>/dev/null); then
          while IFS=: read -r key value; do
            case "$key" in
              "icon") icon="$value" ;;
              "icon_color") icon_color="$value" ;;
              "description") description="$value" ;;
            esac
          done <<< "$plugin_meta_output"
        fi
      fi

      # Cache metadata for later use
      PLUGIN_METADATA_CACHE+=("$plugin_name:$icon:$icon_color:$description")
      PLUGINS_LIST+=("$plugin_name:$plugin_file")
    else
      PLUGIN_ERRORS_LIST+=("$plugin_name:Failed to source plugin")
    fi
  done
}

# Load plugins when script is sourced or executed
load_plugins

# Get cached plugin metadata
get_plugin_metadata() {
  local plugin_name="$1"
  local field="$2"

  for metadata_entry in "${PLUGIN_METADATA_CACHE[@]}"; do
    if [[ "$metadata_entry" == "$plugin_name:"* ]]; then
      local temp="${metadata_entry#*:}"  # Remove plugin_name:
      local icon="${temp%%:*}"          # First field
      temp="${temp#*:}"                 # Remove icon:
      local icon_color="${temp%%:*}"    # Second field
      temp="${temp#*:}"                 # Remove icon_color:
      local description="$temp"         # Third field

      case "$field" in
        "icon") echo "$icon" ;;
        "icon_color") echo "$icon_color" ;;
        "description") echo "$description" ;;
      esac
      return 0
    fi
  done

  # Fallback defaults
  case "$field" in
    "icon") echo "●" ;;
    "icon_color") echo "GREEN" ;;
    "description") echo "" ;;
  esac
}

# Optimized plugin function calls using pre-loaded functions
call_plugin_function() {
  local plugin_name="$1"
  local function_name="$2"
  shift 2

  # Find plugin file
  local plugin_file=""
  for plugin_entry in "${PLUGINS_LIST[@]}"; do
    if [[ "$plugin_entry" == "$plugin_name:"* ]]; then
      plugin_file="${plugin_entry#*:}"
      break
    fi
  done

  if [[ -n "$plugin_file" && -f "$plugin_file" ]]; then
    # Source the plugin in a subshell to avoid function conflicts
    (
      source "$plugin_file" 2>/dev/null
      if declare -f "plugin_$function_name" >/dev/null 2>&1; then
        "plugin_$function_name" "$@"
      fi
    )
  else
    return 1
  fi
}

# Plugin-based session list building (now fully modular with core plugins)
build_session_list() {
  local current_session=""

  # Get current session if inside tmux
  if [[ -n "${TMUX:-}" ]]; then
    current_session=$(tmux display-message -p "#{session_name}" | tr -d '\n')
  fi

  # Get ALL tmux sessions with timestamps for plugin use
  local all_tmux_sessions_with_time
  all_tmux_sessions_with_time=$(tmux list-sessions -F "#{session_last_attached}:#{session_name}" 2>/dev/null || true)

  # Separate active and scratch sessions for plugin consumption
  local active_sessions scratch_sessions
  active_sessions=$(echo "$all_tmux_sessions_with_time" | grep -v ":.*scratch" | sort -rn | cut -d: -f2 || true)
  scratch_sessions=$(echo "$all_tmux_sessions_with_time" | grep ":.*scratch" | sort -rn | cut -d: -f2 || true)

  # Collect all sessions with their priority and metadata from all plugins (core + regular)
  # Format: "timestamp:priority:session_name:plugin_name:metadata"
  local all_sessions_data=()

  # Process all loaded plugins (core plugins are loaded first, so they get processed first)
  for plugin_entry in "${PLUGINS_LIST[@]}"; do
    local plugin_name="${plugin_entry%:*}"

    # Skip if plugin has errors
    local has_error=false
    for error_entry in "${PLUGIN_ERRORS_LIST[@]}"; do
      if [[ "$error_entry" == "$plugin_name:"* ]]; then
        has_error=true
        break
      fi
    done
    if [[ "$has_error" == "true" ]]; then
      continue
    fi

    # Get plugin priority by calling plugin_meta directly
    local plugin_priority=50  # Default priority
    local plugin_file="${plugin_entry#*:}"
    if [[ -f "$plugin_file" ]]; then
      # Source plugin and get priority
      local temp_priority
      temp_priority=$(
        source "$plugin_file" 2>/dev/null
        if declare -f plugin_meta >/dev/null 2>&1; then
          plugin_meta 2>/dev/null | grep "^sort_priority:" | cut -d: -f2
        fi
      )
      if [[ -n "$temp_priority" ]]; then
        plugin_priority="$temp_priority"
      fi
    fi

    # Get plugin sessions
    local plugin_sessions
    plugin_sessions=$(call_plugin_function "$plugin_name" "discover" "$active_sessions" "$scratch_sessions" "$current_session" 2>/dev/null || true)

    if [[ -n "$plugin_sessions" ]]; then
      # Add each plugin session to the data array
      while IFS= read -r session_line; do
        if [[ -n "$session_line" ]]; then
          # Get timestamp for this session if it's an active tmux session
          local timestamp="0"  # Default for non-tmux sessions
          local session_name="$session_line"

          # Remove :current suffix for timestamp lookup
          if [[ "$session_line" == *":current" ]]; then
            session_name="${session_line%:current}"
          fi

          # Try to find timestamp from tmux data
          local tmux_timestamp
          tmux_timestamp=$(echo "$all_tmux_sessions_with_time" | grep ":$session_name$" | cut -d: -f1 2>/dev/null || echo "0")
          if [[ -n "$tmux_timestamp" && "$tmux_timestamp" != "0" ]]; then
            timestamp="$tmux_timestamp"
          fi

          all_sessions_data+=("$timestamp|$plugin_priority|$session_line|$plugin_name|")
        fi
      done <<< "$plugin_sessions"
    fi
  done

  # Sort all sessions by priority first, then by timestamp (within same priority)
  # Format: "timestamp|priority|session_name|plugin_name|metadata"
  local sorted_sessions
  sorted_sessions=($(printf '%s\n' "${all_sessions_data[@]}" | sort -t'|' -k2,2n -k1,1rn))

  # De-duplicate sessions (keep the highest priority version)
  local seen_sessions=()
  local deduplicated_sessions=()
  for session_data in "${sorted_sessions[@]}"; do
    local timestamp="${session_data%%|*}"
    local remaining="${session_data#*|}"
    local priority="${remaining%%|*}"
    remaining="${remaining#*|}"
    local session_line="${remaining%%|*}"

    # Get session name without :current suffix for deduplication
    local session_name="$session_line"
    if [[ "$session_line" == *":current" ]]; then
      session_name="${session_line%:current}"
    fi

    # Check if we've seen this session before
    local already_seen=false
    for seen in "${seen_sessions[@]}"; do
      if [[ "$seen" == "$session_name" ]]; then
        already_seen=true
        break
      fi
    done

    if [[ "$already_seen" == "false" ]]; then
      seen_sessions+=("$session_name")
      deduplicated_sessions+=("$session_data")
    fi
  done

  sorted_sessions=("${deduplicated_sessions[@]}")

  # Format and return the sorted session list
  local session_list=()
  for session_data in "${sorted_sessions[@]}"; do
    local timestamp="${session_data%%|*}"
    local remaining="${session_data#*|}"
    local priority="${remaining%%|*}"
    remaining="${remaining#*|}"
    local session_line="${remaining%%|*}"
    remaining="${remaining#*|}"
    local plugin_name="${remaining%%|*}"

    # Get plugin metadata for display
    local icon icon_color
    icon=$(get_plugin_metadata "$plugin_name" "icon")
    icon_color=$(get_plugin_metadata "$plugin_name" "icon_color")
    
    # Fallback for plugins without metadata
    if [[ -z "$icon" ]]; then
      icon="●"
    fi
    if [[ -z "$icon_color" ]]; then
      icon_color="GREEN"
    fi

    # Convert color name to color code
    local color_code="${GREEN}"
    case "$icon_color" in
      "RED") color_code="$RED" ;;
      "ORANGE") color_code="$ORANGE" ;;
      "YELLOW") color_code="$YELLOW" ;;
      "GREEN") color_code="$GREEN" ;;
      "BLUE") color_code="$BLUE" ;;
      "INDIGO") color_code="$INDIGO" ;;
      "VIOLET") color_code="$VIOLET" ;;
      "PURPLE") color_code="$PURPLE" ;;
      "PINK") color_code="$PINK" ;;
      "CYAN") color_code="$CYAN" ;;
      "BRIGHT_CYAN") color_code="$BRIGHT_CYAN" ;;
      "MAGENTA") color_code="$MAGENTA" ;;
      "BRIGHT_MAGENTA") color_code="$BRIGHT_MAGENTA" ;;
      "WHITE") color_code="$WHITE" ;;
      "BRIGHT_WHITE") color_code="$BRIGHT_WHITE" ;;
      "GREY") color_code="$GREY" ;;
      "DARK_GREY") color_code="$DARK_GREY" ;;
      "BLACK") color_code="$BLACK" ;;
      "BRIGHT_RED") color_code="$BRIGHT_RED" ;;
      "BRIGHT_GREEN") color_code="$BRIGHT_GREEN" ;;
      "BRIGHT_YELLOW") color_code="$BRIGHT_YELLOW" ;;
      "BRIGHT_BLUE") color_code="$BRIGHT_BLUE" ;;
      "GOLD") color_code="$GOLD" ;;
      "SILVER") color_code="$SILVER" ;;
    esac

    # Format session display
    local suffix=""
    local show_suffix=$(get_plugin_metadata "$plugin_name" "show_suffix")
    if [[ "$show_suffix" == "true" ]]; then
      suffix=" ($plugin_name)"
    fi

    # Handle current session indicator
    local display_name="$session_line"
    local is_current_session=false
    if [[ "$session_line" == *":current" ]]; then
      display_name="${session_line%:current}"
      is_current_session=true
    fi

    if [[ "$is_current_session" == "true" ]]; then
      session_list+=("${color_code}→${NC} $display_name$suffix")
    else
      session_list+=("${color_code}${icon}${NC} $display_name$suffix")
    fi
  done

  printf '%s\n' "${session_list[@]}"
}

# Plugin-based preview generation 
generate_preview() {
  local session_name="$1"
  local selection="$2"

  # Extract plugin type from selection
  local session_info
  session_info=$(extract_session_info "$selection")
  local plugin_type="${session_info#*:}"

  # Try to use plugin-specific preview function first
  local metadata
  metadata=$(call_plugin_function "$plugin_type" "resolve" "$session_name" 2>/dev/null || true)
  
  if [[ -n "$metadata" ]]; then
    local preview_result
    preview_result=$(call_plugin_function "$plugin_type" "preview" "$session_name" "$metadata" 2>/dev/null || true)
    
    if [[ -n "$preview_result" ]]; then
      echo "$preview_result"
      return
    fi
  fi

  # Fallback to default tmux session preview for core session types
  if ! tmux has-session -t "$session_name" 2>/dev/null; then
    echo "${RED}Session '$session_name' is not active${NC}"
    echo ""
    echo "This session will be created when selected."
    return
  fi

  # Live session preview
  local active_window
  active_window=$(tmux list-windows -t "$session_name" -f '#{window_active}' -F "#{window_index}" 2>/dev/null | head -1)

  if [[ -n "$active_window" ]]; then
    local active_pane
    active_pane=$(tmux list-panes -t "$session_name:$active_window" -f '#{pane_active}' -F "#{pane_index}" 2>/dev/null | head -1)

    if [[ -n "$active_pane" ]]; then
      local window_count
      window_count=$(tmux list-windows -t "$session_name" 2>/dev/null | wc -l | tr -d ' ')
      echo "${GREEN}● $session_name${NC} (${YELLOW}${window_count} windows${NC})"
      echo "${DARK_GREY}────────────────────────────────────────${NC}"

      tmux capture-pane -ep -t "$session_name:$active_window.$active_pane" 2>/dev/null || {
        echo "${RED}Could not capture session content${NC}"
        echo "Session may be busy or inaccessible"
      }
    fi
  fi
}

# Extract session name and determine which plugin owns it
extract_session_info() {
  local selection="$1"

  # Extract session name
  local session_name
  session_name=$(echo "$selection" | sed -E 's/^[^●→○󱗽★]*[●→○󱗽★][^[:space:]]* ([^[:space:]]+).*/\1/')

  # Determine plugin type by checking for plugin suffix
  local plugin_type=""
  
  # Check for plugin suffix in parentheses
  if echo "$selection" | grep -q "([^)]*)" ; then
    plugin_type=$(echo "$selection" | sed -n 's/.*(\([^)]*\)).*/\1/p')
  fi
  
  # Default to "active" if no plugin suffix found
  if [[ -z "$plugin_type" ]]; then
    # Check for special markers to distinguish core plugins
    if echo "$selection" | grep -q "★"; then
      plugin_type="recent"
    else
      plugin_type="active"
    fi
  fi

  echo "$session_name:$plugin_type"
}

# Fast session switching
switch_to_session() {
  local session_name="$1"
  local selection="$2"

  local session_info
  session_info=$(extract_session_info "$selection")
  local session_type="${session_info#*:}"
  session_name="${session_info%:*}"

  # Try to use plugin-specific switch function first
  local metadata
  metadata=$(call_plugin_function "$session_type" "resolve" "$session_name" 2>/dev/null || true)
  
  if [[ -n "$metadata" ]] && call_plugin_function "$session_type" "switch" "$session_name" "$metadata" 2>/dev/null; then
    # Plugin switch succeeded
    return 0
  else
    # Fallback to basic tmux session switching for core session types
    case "$session_type" in
      "active"|"scratch"|"recent")
        if [[ -n "${TMUX:-}" ]]; then
          tmux switch-client -t "$session_name"
        else
          tmux attach-session -t "$session_name"
        fi
        ;;
      *)
        # Unknown session type or plugin switch failed
        echo "${RED}Failed to switch to session: $session_name (type: $session_type)${NC}" >&2
        exit 1
        ;;
    esac
  fi
}

# Optimized kill/rename functions
kill_session() {
  local selection="$1"
  local session_info
  session_info=$(extract_session_info "$selection")
  local session_name="${session_info%:*}"

  if tmux has-session -t "$session_name" 2>/dev/null; then
    tmux kill-session -t "$session_name" 2>/dev/null || true
  fi
}

rename_session() {
  local selection="$1"
  local session_info
  session_info=$(extract_session_info "$selection")
  local session_name="${session_info%:*}"

  if tmux has-session -t "$session_name" 2>/dev/null; then
    tmux command-prompt -p "Rename session '$session_name' to:" \
      "rename-session -t '$session_name' '%%'" 2>/dev/null || true
  fi
}

start_session() {
  local selection="$1"
  local session_info
  session_info=$(extract_session_info "$selection")
  local plugin_type="${session_info#*:}"
  local session_name="${session_info%:*}"

  # Try to use plugin-specific start function
  local metadata
  metadata=$(call_plugin_function "$plugin_type" "resolve" "$session_name" 2>/dev/null || true)
  
  if [[ -n "$metadata" ]]; then
    call_plugin_function "$plugin_type" "start" "$session_name" "$metadata" 2>/dev/null || true
  fi
}

# Create new session
create_new_session() {
  if [[ -n "${TMUX:-}" ]]; then
    local new_session_name
    new_session_name=$(tmux new-session -d -P -F "#{session_name}")
    tmux switch-client -t "$new_session_name" 2>/dev/null || true
  else
    tmux new-session
  fi
}

# Show help in preview area
show_help_preview() {
  cat << 'EOF'
Session Switcher Help

Keybindings:
  Enter    - Switch to session
  Ctrl-x   - Kill session
  Ctrl-r   - Rename session
  Ctrl-s   - Start in background
  Ctrl-n   - Create new session
  Ctrl-p   - Toggle preview
  Ctrl-d   - Page down in preview
  Ctrl-u   - Page up in preview
  ?        - Show help

Session Icons:
  ● - Active session (green)
  ● - Active worktree session (blue)
  → - Current session
  ● - Tmuxinator config (grey)
  ○ - Inactive worktree (blue outline)
  󱗽 - Scratch session

Navigation:
  ↑/↓ or j/k  - Move selection
  Esc         - Exit without selection

Additional Commands:
  --doctor - Check plugin health
EOF
}

# Session info and troubleshooting mode
debug_mode() {
  echo "tmux-session-manager info"
  echo "========================="
  echo

  echo "Environment:"
  echo "------------"
  echo "Current tmux session: $(tmux display-message -p '#{session_name}' 2>/dev/null || echo 'NOT IN TMUX')"
  echo "Working directory: $(pwd)"
  echo "Bash version: $BASH_VERSION"
  echo

  echo "Plugin loading:"
  echo "---------------"
  load_plugins
  echo "Plugins loaded: ${#PLUGINS_LIST[@]}"
  for plugin_entry in "${PLUGINS_LIST[@]}"; do
    local plugin_name="${plugin_entry%:*}"
    echo "  ✓ $plugin_name"
  done
  echo

  echo "Session generation:"
  echo "------------------"
  local session_list
  session_list=$(build_session_list)

  echo "Session count: $(echo "$session_list" | wc -l | tr -d ' ')"
  
  # Count sessions by plugin type dynamically
  for plugin_entry in "${PLUGINS_LIST[@]}"; do
    local plugin_name="${plugin_entry%%:*}"
    local count
    set +e  # Temporarily disable exit on error for counting
    count=$(echo "$session_list" | grep -c "($plugin_name)" 2>/dev/null)
    # Also count sessions without plugin suffix for core plugins
    if [[ "$plugin_name" == "active" ]]; then
      local active_count
      active_count=$(echo "$session_list" | grep "^\[1;32m●" | grep -v "(" 2>/dev/null | wc -l)
      count=$((count + active_count))
    elif [[ "$plugin_name" == "recent" ]]; then  
      local recent_count
      recent_count=$(echo "$session_list" | grep "^\[1;33m★" 2>/dev/null | wc -l)
      count=$((count + recent_count))
    fi
    set -e  # Re-enable exit on error
    
    if [[ "$count" -gt 0 ]]; then
      echo "$plugin_name sessions: $count"
    fi
  done
  echo

  echo "Full session list:"
  echo "$session_list"
  echo

  # Show plugin-specific information 
  for plugin_entry in "${PLUGINS_LIST[@]}"; do
    local plugin_name="${plugin_entry%%:*}"
    local plugin_sessions
    plugin_sessions=$(echo "$session_list" | grep "($plugin_name)" 2>/dev/null || true)
    
    if [[ -n "$plugin_sessions" ]]; then
      echo "${GREEN}✓${NC} $plugin_name sessions found:"
      echo "$plugin_sessions" | sed 's/^/  /'
      echo
    fi
  done
}

# Doctor command - check plugin health by reading actual plugin files
doctor() {
  echo "tmux-session-manager doctor"
  echo "=========================="
  echo

  echo "Plugin Status:"
  echo "--------------"

  # Load plugins to check their health
  load_plugins

  local all_dependencies=("tmux" "fzf")  # Core dependencies
  local plugin_count=0
  local error_count=0

  if [[ ${#PLUGINS_LIST[@]} -eq 0 ]]; then
    echo "${RED}No plugins loaded${NC}"
    error_count=1
  else
    # Check each plugin
    for plugin_entry in "${PLUGINS_LIST[@]}"; do
      local plugin_name="${plugin_entry%:*}"
      local plugin_file="${plugin_entry#*:}"
      plugin_count=$((plugin_count + 1))

      # Get plugin metadata by sourcing the plugin file
      if source "$plugin_file" 2>/dev/null; then
        local meta
        if meta=$(plugin_meta 2>/dev/null); then
          local description depends install_cmd
          description=$(echo "$meta" | grep "^description:" | cut -d: -f2-)
          depends=$(echo "$meta" | grep "^depends:" | cut -d: -f2)
          install_cmd=$(echo "$meta" | grep "^install_cmd:" | cut -d: -f2-)

          # Add to all dependencies list
          if [[ -n "$depends" ]]; then
            all_dependencies+=("$depends")
          fi

          # Check if dependency is available
          if [[ -n "$depends" ]] && ! command -v "$depends" &>/dev/null; then
            echo "${RED}✗ $plugin_name${NC}: Missing dependency: $depends. Install with: $install_cmd"
            error_count=$((error_count + 1))
          else
            echo "${GREEN}✓ $plugin_name${NC}: $description"
          fi
        else
          echo "${RED}✗ $plugin_name${NC}: Plugin metadata function failed"
          error_count=$((error_count + 1))
        fi
      else
        echo "${RED}✗ $plugin_name${NC}: Failed to load plugin file"
        error_count=$((error_count + 1))
      fi
    done

    # Check plugin errors from load_plugins
    for error_entry in "${PLUGIN_ERRORS_LIST[@]}"; do
      local plugin_name="${error_entry%:*}"
      local error_msg="${error_entry#*:}"
      echo "${RED}✗ $plugin_name${NC}: $error_msg"
      error_count=$((error_count + 1))
    done
  fi

  echo
  echo "System Dependencies:"
  echo "-------------------"

  # Remove duplicates from all_dependencies and check each one
  local -a unique_deps
  for dep in "${all_dependencies[@]}"; do
    local found=false
    for unique_dep in "${unique_deps[@]}"; do
      if [[ "$dep" == "$unique_dep" ]]; then
        found=true
        break
      fi
    done
    if [[ "$found" == "false" ]]; then
      unique_deps+=("$dep")
    fi
  done

  for dep in "${unique_deps[@]}"; do
    if command -v "$dep" &>/dev/null; then
      echo "${GREEN}✓ $dep${NC}: $(command -v "$dep")"
    else
      echo "${RED}✗ $dep${NC}: not found"
    fi
  done

  echo
  echo "Summary:"
  echo "--------"
  echo "Plugins loaded: $plugin_count"
  if [[ $error_count -eq 0 ]]; then
    echo "${GREEN}All systems operational!${NC}"
  else
    echo "${RED}Found $error_count issue(s) that may affect functionality${NC}"
  fi
}

# Check dependencies
check_dependencies() {
  local deps=("tmux" "fzf")
  local missing=()

  for dep in "${deps[@]}"; do
    if ! command -v "$dep" &> /dev/null; then
      missing+=("$dep")
    fi
  done

  if [[ ${#missing[@]} -gt 0 ]]; then
    echo -e "${RED}Missing dependencies: ${missing[*]}${NC}" >&2
    echo "Run 'tmux-session-manager --doctor' for more information" >&2
    exit 1
  fi
}

# Build error title for plugin failures (simplified)
build_error_title() {
  local error_count=0
  local deps=("tmuxinator" "git")
  for dep in "${deps[@]}"; do
    if ! command -v "$dep" &>/dev/null; then
      ((error_count++))
    fi
  done

  if [[ $error_count -gt 0 ]]; then
    echo " [missing $error_count dependencies]"
  fi
}

# Main function
main() {
  load_plugins
  check_dependencies

  local session_list
  session_list=$(build_session_list)

  if [[ -z "$session_list" ]]; then
    exit 0
  fi

  # Load preview preference
  local preview_enabled
  preview_enabled=$(load_preview_preference)

  # Build title with potential error information
  local title="Select session (?: help)"
  local error_suffix
  error_suffix=$(build_error_title)
  if [[ -n "$error_suffix" ]]; then
    title="$title$error_suffix"
  fi

  # Use fzf for selection (with tmux popup if inside tmux)
  local result
  if [[ -n "${TMUX:-}" && -z "${FORCE_NO_POPUP:-}" ]]; then
    # Inside tmux - use popup with temporary files for input/output
    local input_file output_file preview_script
    input_file=$(mktemp)
    output_file=$(mktemp)
    preview_script=$(mktemp)
    echo "$session_list" > "$input_file"

    # Create optimized preview script using the same bash
    cat > "$preview_script" << 'EOF'
#!/opt/homebrew/bin/bash
source_script="$1"
selection="$2"
mode="$3"

# Colors for output (copied to avoid sourcing main script)
readonly RED=$'\033[0;31m'
readonly GREEN=$'\033[1;32m'
readonly YELLOW=$'\033[1;33m'
readonly BLUE=$'\033[0;34m'
readonly DARK_GREY=$'\033[0;90m'
readonly NC=$'\033[0m'

# Show help in preview area
show_help_preview() {
  cat << 'HELP_EOF'
Session Switcher Help

Keybindings:
  Enter    - Switch to session
  Ctrl-x   - Kill session
  Ctrl-r   - Rename session
  Ctrl-s   - Start in background
  Ctrl-n   - Create new session
  Ctrl-p   - Toggle preview
  Ctrl-d   - Page down in preview
  Ctrl-u   - Page up in preview
  ?        - Show help

Session Icons:
  ● - Active session (green)
  ● - Active worktree session (blue)
  → - Current session
  ● - Tmuxinator config (grey)
  ○ - Inactive worktree (blue outline)
  󱗽 - Scratch session

Navigation:
  ↑/↓ or j/k  - Move selection
  Esc         - Exit without selection

Additional Commands:
  --doctor - Check plugin health
HELP_EOF
}


case "$mode" in
  "HELP")
    show_help_preview
    ;;
  "PREVIEW")
    session_name=$(echo "$selection" | sed -E 's/^[^●→○󱗽★]*[●→○󱗽★][^[:space:]]* ([^[:space:]]+).*/\1/')
    generate_preview "$session_name" "$selection"
    ;;
  *)
    show_help_preview
    ;;
esac
EOF
    chmod +x "$preview_script"

    # Determine initial preview state
    local initial_preview_visible="right:50%:wrap"
    if [[ "$preview_enabled" == "false" ]]; then
      initial_preview_visible="hidden"
    fi

    tmux display-popup -E -w 60% -h 40% \
      "cat '$input_file' | fzf --prompt='$title: ' --ansi --reverse --border --expect=ctrl-x,ctrl-r,ctrl-s,ctrl-n,ctrl-p --preview='$preview_script \"$0\" {} PREVIEW' --preview-window=$initial_preview_visible --bind='ctrl-p:toggle-preview+change-preview($preview_script \"$0\" {} PREVIEW)+change-preview-window(right:50%:wrap)' --bind='?:change-preview($preview_script \"$0\" {} HELP)+change-preview-window(right:50%:wrap)' --bind='ctrl-d:preview-page-down' --bind='ctrl-u:preview-page-up' > '$output_file'" 2>/dev/null || true

    result=$(cat "$output_file" 2>/dev/null || true)
    rm -f "$input_file" "$output_file" "$preview_script"
  else
    # Outside tmux - regular fzf
    result=$(echo "$session_list" | fzf \
      --height=40% \
      --border \
      --prompt="$title: " \
      --preview='echo -e "Session Switcher Help\n\nKeybindings:\n  Enter    - Switch to session\n  Ctrl-x   - Kill session\n  Ctrl-r   - Rename session\n  Ctrl-s   - Start in background\n  Ctrl-n   - Create new session\n  ?        - Toggle help\n\nSession Icons:\n  ● - Active session\n  → - Current session\n  ● - Tmuxinator config (grey)\n  ● - Git worktree (blue)\n  󱗽 - Scratch session\n\nNavigation:\n  ↑/↓ or j/k  - Move selection\n  Esc         - Exit without selection"' \
      --preview-window="hidden" \
      --ansi \
      --expect=ctrl-x,ctrl-r,ctrl-s,ctrl-n,ctrl-p \
      --bind='?:toggle-preview' 2>/dev/null || true)
  fi

  if [[ -n "$result" ]]; then
    local key
    local selection
    key=$(echo "$result" | head -n1)
    selection=$(echo "$result" | tail -n1)

    if [[ -n "$selection" ]]; then
      case "$key" in
        "ctrl-x")
          kill_session "$selection"
          exec "$0" "$@"
          ;;
        "ctrl-r")
          rename_session "$selection"
          exec "$0" "$@"
          ;;
        "ctrl-s")
          start_session "$selection"
          exec "$0" "$@"
          ;;
        "ctrl-n")
          create_new_session
          ;;
        "ctrl-p")
          if [[ "$preview_enabled" == "true" ]]; then
            save_preview_preference "false"
          else
            save_preview_preference "true"
          fi
          exec "$0" "$@"
          ;;
        "")
          switch_to_session "" "$selection"
          ;;
      esac
    fi
  fi
}

# Only execute main logic if script is run directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
# Handle command line arguments
case "${1:-}" in
  "--doctor")
    doctor
    exit 0
    ;;
  "--info")
    debug_mode
    exit 0
    ;;
  "--no-popup")
    FORCE_NO_POPUP=1
    main "$@"
    ;;
  "--preview")
    # Called as preview function (legacy support)
    selection="$2"
    session_name=$(echo "$selection" | sed -E 's/^[^●→○󱗽★]*[●→○󱗽★][^[:space:]]* ([^[:space:]]+).*/\1/')
    generate_preview "$session_name" "$selection"
    exit 0
    ;;
  "--help-preview")
    show_help_preview
    exit 0
    ;;
  "--help"|"-h")
    echo "tmux-session-manager - Plugin-based tmux session manager"
    echo ""
    echo "Usage: $0 [options]"
    echo ""
    echo "Options:"
    echo "  --doctor           Check plugin health and dependencies"
    echo "  --info             Show session info and troubleshooting"
    echo "  --no-popup         Force regular fzf instead of tmux popup"
    echo "  --help, -h         Show this help message"
    echo ""
    echo "Interactive mode (default):"
    echo "  Run without arguments to open the session selector"
    exit 0
    ;;
  "")
    main "$@"
    ;;
  *)
    echo "Unknown option: $1" >&2
    echo "Use --help for usage information" >&2
    exit 1
    ;;
esac
fi  # End of direct execution check
